import React, { useState, useEffect, useRef } from 'react';
import { 
  Card, Button, Upload, message, Space, 
  Breadcrumb, Input, Typography, List, Row, Col, Spin, Modal, Checkbox, Dropdown 
} from 'antd';
import type { MenuProps } from 'antd';
import {
  FolderOutlined, FileOutlined, UploadOutlined, 
  PlayCircleOutlined, DeleteOutlined, PlusOutlined,
  ReloadOutlined, DownloadOutlined, ClearOutlined,
  FolderOpenOutlined, CodeOutlined, EditOutlined, FileAddOutlined,
  CodeSandboxOutlined, MoreOutlined, FullscreenOutlined, FullscreenExitOutlined
} from '@ant-design/icons';
import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels';
import axios from '../api/axios';
import dayjs from 'dayjs';
import TerminalModal from '../components/TerminalModal';
import CodeEditor from '../components/CodeEditor';
import CsvViewer from '../components/CsvViewer';

const { Text } = Typography;

interface FileItem {
  name: string;
  path: string;
  type: 'file' | 'directory';
  size: number;
  modified: string;
  extension?: string;
}

const Workspace: React.FC = () => {
  const [files, setFiles] = useState<FileItem[]>([]);
  const [currentPath, setCurrentPath] = useState('');
  const [loading, setLoading] = useState(false);
  const [executing, setExecuting] = useState(false);
  const [consoleOutput, setConsoleOutput] = useState<string[]>([]);
  const [selectedFile, setSelectedFile] = useState<string>('');
  const [createDirVisible, setCreateDirVisible] = useState(false);
  const [newDirName, setNewDirName] = useState('');
  const [editModalVisible, setEditModalVisible] = useState(false);
  const [editingFile, setEditingFile] = useState<{ path: string; name: string; content: string } | null>(null);
  const [fileContent, setFileContent] = useState('');
  const [saving, setSaving] = useState(false);
  const [selectedItems, setSelectedItems] = useState<string[]>([]);
  const [terminalVisible, setTerminalVisible] = useState(false);
  const [terminalScript, setTerminalScript] = useState<{ path: string; name: string } | null>(null);
  const [renamingItem, setRenamingItem] = useState<{ path: string; name: string } | null>(null);
  const [newName, setNewName] = useState('');
  const [createFileVisible, setCreateFileVisible] = useState(false);
  const [newFileName, setNewFileName] = useState('');
  const [consoleFullscreen, setConsoleFullscreen] = useState(false);
  const consoleRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    loadFiles();
  }, [currentPath]);

  useEffect(() => {
    // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
    if (consoleRef.current) {
      consoleRef.current.scrollTop = consoleRef.current.scrollHeight;
    }
  }, [consoleOutput]);

  const addConsoleLog = (text: string, type: 'info' | 'success' | 'error' | 'warning' = 'info') => {
    const timestamp = dayjs().format('HH:mm:ss');
    const colorMap = {
      info: '#00ff00',
      success: '#00ff00',
      error: '#ff0000',
      warning: '#ffff00'
    };
    setConsoleOutput(prev => [...prev, `[${timestamp}] ${text}`]);
  };

  const clearConsole = () => {
    setConsoleOutput([]);
    addConsoleLog('æ§åˆ¶å°å·²æ¸…ç©º', 'info');
  };

  const loadFiles = async () => {
    setLoading(true);
    addConsoleLog(`åŠ è½½ç›®å½•: ${currentPath || 'æ ¹ç›®å½•'}`, 'info');
    try {
      const response = await axios.get('/workspace/files', {
        params: { path: currentPath }
      });
      setFiles(response.data.items);
      setSelectedItems([]); // æ¸…ç©ºé€‰æ‹©
      addConsoleLog(`âœ“ æ‰¾åˆ° ${response.data.items.length} ä¸ªé¡¹ç›®`, 'success');
    } catch (error: any) {
      const errorMsg = 'åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥: ' + (error.response?.data?.detail || error.message);
      message.error(errorMsg);
      addConsoleLog(`âœ— ${errorMsg}`, 'error');
    } finally {
      setLoading(false);
    }
  };

  const handleFileClick = (record: FileItem) => {
    if (record.type === 'directory') {
      setCurrentPath(record.path);
      addConsoleLog(`è¿›å…¥ç›®å½•: ${record.name}`, 'info');
    }
  };

  const handleBreadcrumbClick = (path: string) => {
    setCurrentPath(path);
    addConsoleLog(`è¿”å›: ${path || 'æ ¹ç›®å½•'}`, 'info');
  };

  const handleUpload = async (file: File) => {
    const formData = new FormData();
    formData.append('file', file);
    
    addConsoleLog(`å¼€å§‹ä¸Šä¼ : ${file.name}`, 'info');
    try {
      await axios.post('/workspace/upload', formData, {
        params: { path: currentPath },
        headers: { 'Content-Type': 'multipart/form-data' }
      });
      message.success('æ–‡ä»¶ä¸Šä¼ æˆåŠŸ');
      addConsoleLog(`âœ“ ä¸Šä¼ æˆåŠŸ: ${file.name}`, 'success');
      loadFiles();
    } catch (error: any) {
      const errorMsg = 'ä¸Šä¼ å¤±è´¥: ' + (error.response?.data?.detail || error.message);
      message.error(errorMsg);
      addConsoleLog(`âœ— ${errorMsg}`, 'error');
    }
    
    return false;
  };

  const handleExecute = async (filePath: string, fileName: string) => {
    setSelectedFile(filePath);
    setExecuting(true);
    
    addConsoleLog('='.repeat(60), 'info');
    addConsoleLog(`æ‰§è¡Œè„šæœ¬: ${fileName}`, 'info');
    addConsoleLog(`æ–‡ä»¶è·¯å¾„: ${filePath}`, 'info');
    addConsoleLog('='.repeat(60), 'info');
    addConsoleLog('æ­£åœ¨æ‰§è¡Œ...', 'warning');

    try {
      const response = await axios.post('/workspace/execute', null, {
        params: { file_path: filePath }
      });

      const scriptDir = filePath.substring(0, filePath.lastIndexOf('/')) || 'æ ¹ç›®å½•';
      
      addConsoleLog('', 'info');
      addConsoleLog(`æ‰§è¡Œç”¨æˆ·: ${response.data.executed_by}`, 'info');
      addConsoleLog(`æ‰§è¡Œæ—¶é—´: ${dayjs(response.data.executed_at).format('YYYY-MM-DD HH:mm:ss')}`, 'info');
      addConsoleLog(`å·¥ä½œç›®å½•: ${scriptDir}`, 'info');
      addConsoleLog(`è¿”å›ç : ${response.data.returncode}`, 'info');
      addConsoleLog(`çŠ¶æ€: ${response.data.success ? 'âœ“ æˆåŠŸ' : 'âœ— å¤±è´¥'}`, response.data.success ? 'success' : 'error');
      addConsoleLog('', 'info');
      addConsoleLog('=== æ ‡å‡†è¾“å‡º ===', 'info');
      
      if (response.data.stdout) {
        response.data.stdout.split('\n').forEach((line: string) => {
          addConsoleLog(line, 'info');
        });
      } else {
        addConsoleLog('(æ— è¾“å‡º)', 'info');
      }
      
      if (response.data.stderr) {
        addConsoleLog('', 'info');
        addConsoleLog('=== é”™è¯¯è¾“å‡º ===', 'warning');
        response.data.stderr.split('\n').forEach((line: string) => {
          addConsoleLog(line, 'error');
        });
      }
      
      addConsoleLog('', 'info');
      addConsoleLog('='.repeat(60), 'info');
      addConsoleLog('æ‰§è¡Œå®Œæˆï¼', 'success');
      addConsoleLog('æç¤º: å¦‚æœ‰æ–‡ä»¶ç”Ÿæˆï¼Œè¯·ç‚¹å‡»åˆ·æ–°æŸ¥çœ‹', 'info');
      addConsoleLog('='.repeat(60), 'info');
      
      if (response.data.success) {
        message.success('è„šæœ¬æ‰§è¡ŒæˆåŠŸï¼');
        // è‡ªåŠ¨åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
        setTimeout(() => loadFiles(), 1000);
      }
    } catch (error: any) {
      const errorMsg = 'æ‰§è¡Œå¤±è´¥: ' + (error.response?.data?.detail || error.message);
      addConsoleLog(`âœ— ${errorMsg}`, 'error');
      message.error(errorMsg);
    } finally {
      setExecuting(false);
    }
  };

  const handleToggleSelect = (filePath: string) => {
    setSelectedItems(prev => {
      if (prev.includes(filePath)) {
        return prev.filter(p => p !== filePath);
      } else {
        return [...prev, filePath];
      }
    });
  };

  const handleSelectAll = () => {
    if (selectedItems.length === files.length) {
      setSelectedItems([]);
    } else {
      setSelectedItems(files.map(f => f.path));
    }
  };

  const handleBatchDelete = async () => {
    if (selectedItems.length === 0) {
      message.warning('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„æ–‡ä»¶');
      return;
    }

    Modal.confirm({
      title: 'æ‰¹é‡åˆ é™¤ç¡®è®¤',
      content: `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedItems.length} ä¸ªé¡¹ç›®å—ï¼Ÿ`,
      okText: 'ç¡®å®š',
      cancelText: 'å–æ¶ˆ',
      okType: 'danger',
      onOk: async () => {
        addConsoleLog(`æ‰¹é‡åˆ é™¤ ${selectedItems.length} ä¸ªé¡¹ç›®`, 'warning');
        let successCount = 0;
        let failCount = 0;

        for (const filePath of selectedItems) {
          try {
            await axios.delete('/workspace/delete', {
              params: { file_path: filePath }
            });
            successCount++;
            addConsoleLog(`âœ“ å·²åˆ é™¤: ${filePath}`, 'success');
          } catch (error: any) {
            failCount++;
            addConsoleLog(`âœ— åˆ é™¤å¤±è´¥: ${filePath}`, 'error');
          }
        }

        message.success(`åˆ é™¤å®Œæˆï¼šæˆåŠŸ ${successCount} ä¸ªï¼Œå¤±è´¥ ${failCount} ä¸ª`);
        setSelectedItems([]);
        loadFiles();
      }
    });
  };

  const handleCreateDir = async () => {
    if (!newDirName.trim()) {
      message.error('è¯·è¾“å…¥ç›®å½•åç§°');
      return;
    }

    const dirPath = currentPath ? `${currentPath}/${newDirName}` : newDirName;
    addConsoleLog(`åˆ›å»ºç›®å½•: ${newDirName}`, 'info');

    try {
      await axios.post('/workspace/mkdir', null, {
        params: { dir_path: dirPath }
      });
      message.success('ç›®å½•åˆ›å»ºæˆåŠŸ');
      addConsoleLog(`âœ“ ç›®å½•å·²åˆ›å»º: ${newDirName}`, 'success');
      setCreateDirVisible(false);
      setNewDirName('');
      loadFiles();
    } catch (error: any) {
      const errorMsg = 'åˆ›å»ºç›®å½•å¤±è´¥: ' + (error.response?.data?.detail || error.message);
      message.error(errorMsg);
      addConsoleLog(`âœ— ${errorMsg}`, 'error');
    }
  };

  const handleRename = async () => {
    if (!renamingItem || !newName.trim()) {
      message.error('è¯·è¾“å…¥æ–°åç§°');
      return;
    }

    if (newName === renamingItem.name) {
      setRenamingItem(null);
      setNewName('');
      return;
    }

    const oldPath = renamingItem.path;
    const newPath = currentPath ? `${currentPath}/${newName}` : newName;
    
    addConsoleLog(`é‡å‘½å: ${renamingItem.name} â†’ ${newName}`, 'info');

    try {
      await axios.post('/workspace/rename', null, {
        params: { 
          old_path: oldPath,
          new_path: newPath
        }
      });
      message.success('é‡å‘½åæˆåŠŸ');
      addConsoleLog(`âœ“ å·²é‡å‘½å: ${renamingItem.name} â†’ ${newName}`, 'success');
      setRenamingItem(null);
      setNewName('');
      loadFiles();
    } catch (error: any) {
      const errorMsg = 'é‡å‘½åå¤±è´¥: ' + (error.response?.data?.detail || error.message);
      message.error(errorMsg);
      addConsoleLog(`âœ— ${errorMsg}`, 'error');
    }
  };

  const downloadConsoleLog = () => {
    const logContent = consoleOutput.join('\n');
    const blob = new Blob([logContent], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `console_log_${dayjs().format('YYYYMMDDHHmmss')}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    addConsoleLog('âœ“ æ—¥å¿—å·²ä¸‹è½½', 'success');
  };

  const downloadFile = async (filePath: string, fileName: string) => {
    addConsoleLog(`ä¸‹è½½æ–‡ä»¶: ${fileName}`, 'info');
    try {
      const response = await axios.get('/workspace/download', {
        params: { file_path: filePath },
        responseType: 'blob'
      });
      
      const url = URL.createObjectURL(response.data);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      message.success('æ–‡ä»¶ä¸‹è½½æˆåŠŸ');
      addConsoleLog(`âœ“ å·²ä¸‹è½½: ${fileName}`, 'success');
    } catch (error: any) {
      const errorMsg = 'ä¸‹è½½å¤±è´¥: ' + (error.response?.data?.detail || error.message);
      message.error(errorMsg);
      addConsoleLog(`âœ— ${errorMsg}`, 'error');
    }
  };

  const handleEditFile = async (filePath: string, fileName: string) => {
    addConsoleLog(`æ‰“å¼€ç¼–è¾‘: ${fileName}`, 'info');
    try {
      const response = await axios.get('/workspace/read', {
        params: { file_path: filePath }
      });
      
      setEditingFile({ path: filePath, name: fileName, content: response.data.content });
      setFileContent(response.data.content);
      setEditModalVisible(true);
      addConsoleLog(`âœ“ æ–‡ä»¶å·²åŠ è½½`, 'success');
    } catch (error: any) {
      const errorMsg = 'è¯»å–æ–‡ä»¶å¤±è´¥: ' + (error.response?.data?.detail || error.message);
      message.error(errorMsg);
      addConsoleLog(`âœ— ${errorMsg}`, 'error');
    }
  };

  const handleSaveFile = async () => {
    if (!editingFile) return;
    
    setSaving(true);
    addConsoleLog(`ä¿å­˜æ–‡ä»¶: ${editingFile.name}`, 'info');
    
    try {
      await axios.put('/workspace/update', {
        file_path: editingFile.path,
        content: fileContent
      });
      
      message.success('æ–‡ä»¶ä¿å­˜æˆåŠŸ');
      addConsoleLog(`âœ“ å·²ä¿å­˜: ${editingFile.name}`, 'success');
      setEditModalVisible(false);
      setEditingFile(null);
      loadFiles();
    } catch (error: any) {
      const errorMsg = 'ä¿å­˜å¤±è´¥: ' + (error.response?.data?.detail || error.message);
      message.error(errorMsg);
      addConsoleLog(`âœ— ${errorMsg}`, 'error');
    } finally {
      setSaving(false);
    }
  };

  const handleCreateNewFile = () => {
    setNewFileName('new_script.py');
    setCreateFileVisible(true);
  };

  const handleConfirmCreateFile = () => {
    if (!newFileName.trim()) {
      message.error('è¯·è¾“å…¥æ–‡ä»¶å');
      return;
    }

    // ç¡®ä¿æ–‡ä»¶åä»¥.pyç»“å°¾
    let fileName = newFileName.trim();
    if (!fileName.endsWith('.py')) {
      fileName += '.py';
    }

    const filePath = currentPath ? `${currentPath}/${fileName}` : fileName;
    const defaultContent = `#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
${fileName.replace('.py', '')}
"""

print("Hello, World!")
`;
    
    setEditingFile({ path: filePath, name: fileName, content: defaultContent });
    setFileContent(defaultContent);
    setEditModalVisible(true);
    setCreateFileVisible(false);
    setNewFileName('');
    addConsoleLog(`åˆ›å»ºæ–°æ–‡ä»¶: ${fileName}`, 'info');
  };

  const formatSize = (bytes: number) => {
    if (bytes === 0) return '-';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
  };

  const getBreadcrumbs = () => {
    if (!currentPath) return [{ path: '', name: 'æ ¹ç›®å½•' }];
    
    const parts = currentPath.split('/');
    const breadcrumbs = [{ path: '', name: 'æ ¹ç›®å½•' }];
    
    let accumulated = '';
    parts.forEach(part => {
      accumulated = accumulated ? `${accumulated}/${part}` : part;
      breadcrumbs.push({ path: accumulated, name: part });
    });
    
    return breadcrumbs;
  };

  return (
    <div style={{ height: 'calc(100vh - 120px)', position: 'relative' }}>
      {/* æ§åˆ¶å°å…¨å±æ¨¡å¼ */}
      {consoleFullscreen ? (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          zIndex: 1000,
          background: '#fff'
        }}>
          <Card
            title={
              <Space>
                <FolderOpenOutlined />
                <span>æ–‡ä»¶æµè§ˆå™¨</span>
              </Space>
            }
            extra={
              <Space>
                <Button
                  size="small"
                  type="primary"
                  icon={<FileAddOutlined />}
                  onClick={handleCreateNewFile}
                >
                  æ–°å»ºæ–‡ä»¶
                </Button>
                <Button
                  size="small"
                  icon={<PlusOutlined />}
                  onClick={() => setCreateDirVisible(true)}
                >
                  æ–°å»ºç›®å½•
                </Button>
                <Upload
                  beforeUpload={handleUpload}
                  showUploadList={false}
                >
                  <Button size="small" icon={<UploadOutlined />}>ä¸Šä¼ </Button>
                </Upload>
                <Button size="small" icon={<ReloadOutlined />} onClick={loadFiles}>
                  åˆ·æ–°
                </Button>
              </Space>
            }
            style={{ height: '100%', display: 'flex', flexDirection: 'column' }}
            bodyStyle={{ flex: 1, overflow: 'auto', padding: '16px' }}
          >
            <Space direction="vertical" style={{ width: '100%', marginBottom: 16 }}>
              <Breadcrumb>
                {getBreadcrumbs().map((item, index) => (
                  <Breadcrumb.Item key={index}>
                    <a onClick={() => handleBreadcrumbClick(item.path)}>
                      {item.name}
                    </a>
                  </Breadcrumb.Item>
                ))}
              </Breadcrumb>
              
              {files.length > 0 && (
                <Space>
                  <Checkbox
                    checked={selectedItems.length === files.length && files.length > 0}
                    indeterminate={selectedItems.length > 0 && selectedItems.length < files.length}
                    onChange={handleSelectAll}
                  >
                    å…¨é€‰
                  </Checkbox>
                  {selectedItems.length > 0 && (
                    <Button
                      danger
                      size="small"
                      icon={<DeleteOutlined />}
                      onClick={handleBatchDelete}
                    >
                      åˆ é™¤é€‰ä¸­ ({selectedItems.length})
                    </Button>
                  )}
                </Space>
              )}
            </Space>

            <Spin spinning={loading}>
              <List
                dataSource={files}
                renderItem={(item) => (
                  <List.Item
                    key={item.path}
                    style={{
                      padding: '12px',
                      cursor: item.type === 'directory' ? 'pointer' : 'default',
                      borderRadius: '4px',
                      marginBottom: '4px',
                      background: selectedFile === item.path ? '#e6f7ff' : 'transparent'
                    }}
                    onMouseEnter={(e) => {
                      if (item.type === 'directory') {
                        e.currentTarget.style.background = '#f5f5f5';
                      }
                    }}
                    onMouseLeave={(e) => {
                      if (selectedFile !== item.path) {
                        e.currentTarget.style.background = 'transparent';
                      }
                    }}
                    onClick={() => item.type === 'directory' && handleFileClick(item)}
                    actions={[
                      item.type === 'file' && item.extension === '.py' && (
                        <Button
                          type="primary"
                          size="small"
                          icon={<PlayCircleOutlined />}
                          onClick={(e) => {
                            e.stopPropagation();
                            handleExecute(item.path, item.name);
                          }}
                          loading={executing && selectedFile === item.path}
                        >
                          æ‰§è¡Œ
                        </Button>
                      ),
                      item.type === 'file' && item.extension === '.py' && (
                        <Button
                          size="small"
                          icon={<CodeSandboxOutlined />}
                          onClick={(e) => {
                            e.stopPropagation();
                            addConsoleLog('='.repeat(60), 'info');
                            addConsoleLog(`å¯åŠ¨äº¤äº’å¼æ‰§è¡Œ: ${item.name}`, 'info');
                            addConsoleLog('æç¤º: äº¤äº’å¼ç»ˆç«¯å°†åœ¨æ–°çª—å£æ‰“å¼€ï¼Œæ‰€æœ‰è¾“å‡ºä¼šåŒæ­¥è®°å½•åˆ°æ—¥å¿—', 'info');
                            addConsoleLog('='.repeat(60), 'info');
                            setTerminalScript({ path: item.path, name: item.name });
                            setTerminalVisible(true);
                          }}
                        >
                          äº¤äº’å¼
                        </Button>
                      ),
                      <Dropdown
                        key="more"
                        menu={{
                          items: [
                            item.type === 'file' && {
                              key: 'edit',
                              icon: <EditOutlined />,
                              label: 'ç¼–è¾‘',
                              onClick: () => handleEditFile(item.path, item.name)
                            },
                            item.type === 'file' && {
                              key: 'download',
                              icon: <DownloadOutlined />,
                              label: 'ä¸‹è½½',
                              onClick: () => downloadFile(item.path, item.name)
                            },
                            {
                              key: 'rename',
                              icon: <EditOutlined />,
                              label: 'é‡å‘½å',
                              onClick: () => {
                                setRenamingItem({ path: item.path, name: item.name });
                                setNewName(item.name);
                              }
                            }
                          ].filter(Boolean) as MenuProps['items']
                        }}
                        trigger={['click']}
                      >
                        <Button
                          size="small"
                          icon={<MoreOutlined />}
                          onClick={(e) => e.stopPropagation()}
                        >
                          æ›´å¤š
                        </Button>
                      </Dropdown>
                    ].filter(Boolean)}
                  >
                    <List.Item.Meta
                      avatar={
                        <Space>
                          <Checkbox
                            checked={selectedItems.includes(item.path)}
                            onChange={(e) => {
                              e.stopPropagation();
                              handleToggleSelect(item.path);
                            }}
                            onClick={(e) => e.stopPropagation()}
                          />
                          {item.type === 'directory' ? (
                            <FolderOutlined style={{ fontSize: 24, color: '#1890ff' }} />
                          ) : (
                            <FileOutlined style={{ fontSize: 24, color: item.extension === '.py' ? '#52c41a' : '#8c8c8c' }} />
                          )}
                        </Space>
                      }
                      title={
                        <div onDoubleClick={(e) => {
                          e.stopPropagation();
                          if (item.type === 'file') {
                            handleEditFile(item.path, item.name);
                          }
                        }}>
                          <Text strong={item.type === 'directory'}>{item.name}</Text>
                        </div>
                      }
                      description={
                        <Space size="large">
                          <Text type="secondary">{formatSize(item.size)}</Text>
                          <Text type="secondary">{dayjs(item.modified).format('YYYY-MM-DD HH:mm')}</Text>
                        </Space>
                      }
                    />
                  </List.Item>
                )}
              />
            </Spin>
          </Card>
        </Col>

        {/* å³ä¾§æ§åˆ¶å° */}
        <Col span={14} style={{ height: '100%' }}>
          <Card
            title={
              <Space>
                <CodeOutlined />
                <span>æ§åˆ¶å°è¾“å‡º</span>
                {executing && <Spin size="small" />}
              </Space>
            }
            extra={
              <Space>
                <Button
                  size="small"
                  icon={consoleFullscreen ? <FullscreenExitOutlined /> : <FullscreenOutlined />}
                  onClick={() => setConsoleFullscreen(!consoleFullscreen)}
                  title={consoleFullscreen ? "é€€å‡ºå…¨å±" : "å…¨å±æŸ¥çœ‹"}
                >
                  {consoleFullscreen ? "é€€å‡ºå…¨å±" : "å…¨å±"}
                </Button>
                <Button
                  size="small"
                  icon={<DownloadOutlined />}
                  onClick={downloadConsoleLog}
                  disabled={consoleOutput.length === 0}
                >
                  ä¸‹è½½æ—¥å¿—
                </Button>
                <Button
                  size="small"
                  icon={<ClearOutlined />}
                  onClick={clearConsole}
                >
                  æ¸…ç©º
                </Button>
              </Space>
            }
            style={{ height: '100%', display: 'flex', flexDirection: 'column' }}
            bodyStyle={{ flex: 1, overflow: 'hidden', padding: 0 }}
          >
            <div
              ref={consoleRef}
              style={{
                height: '100%',
                background: '#000',
                color: '#00ff00',
                padding: '16px',
                fontFamily: 'Consolas, Monaco, "Courier New", monospace',
                fontSize: '13px',
                overflow: 'auto',
                whiteSpace: 'pre-wrap',
                wordBreak: 'break-all'
              }}
            >
              {consoleOutput.length === 0 ? (
                <Text style={{ color: '#666' }}>
                  ç­‰å¾…æ‰§è¡Œè„šæœ¬...
                  <br /><br />
                  æç¤ºï¼š
                  <br />â€¢ ç‚¹å‡»"æ‰§è¡Œ"æŒ‰é’® - æ™®é€šæ¨¡å¼ï¼ŒæŸ¥çœ‹è¾“å‡º
                  <br />â€¢ ç‚¹å‡»"äº¤äº’å¼"æŒ‰é’® - å¼¹çª—ç»ˆç«¯ï¼Œæ”¯æŒè¾“å…¥
                  <br />â€¢ äº¤äº’å¼ç»ˆç«¯çš„è¾“å‡ºä¼šåŒæ­¥è®°å½•åˆ°æ—¥å¿—
                  <br />â€¢ å¯ä»¥ä¸‹è½½æ—¥å¿—æˆ–æ¸…ç©ºæ§åˆ¶å°
                </Text>
              ) : (
                consoleOutput.map((line, index) => (
                  <div key={index}>{line}</div>
                ))
              )}
            </div>
          </Card>
        </Col>
      </Row>

      {/* æ–°å»ºæ–‡ä»¶å¯¹è¯æ¡† */}
      <Modal
        title="æ–°å»ºæ–‡ä»¶"
        open={createFileVisible}
        onOk={handleConfirmCreateFile}
        onCancel={() => {
          setCreateFileVisible(false);
          setNewFileName('');
        }}
        okText="åˆ›å»º"
        cancelText="å–æ¶ˆ"
      >
        <Space direction="vertical" style={{ width: '100%' }}>
          <Text type="secondary">è¯·è¾“å…¥æ–‡ä»¶åï¼ˆè‡ªåŠ¨æ·»åŠ .pyåç¼€ï¼‰</Text>
          <Input
            placeholder="ä¾‹å¦‚: my_script"
            value={newFileName}
            onChange={(e) => setNewFileName(e.target.value)}
            onPressEnter={handleConfirmCreateFile}
            autoFocus
            suffix=".py"
          />
        </Space>
      </Modal>

      {/* åˆ›å»ºç›®å½•å¯¹è¯æ¡† */}
      <Modal
        title="åˆ›å»ºç›®å½•"
        open={createDirVisible}
        onOk={handleCreateDir}
        onCancel={() => {
          setCreateDirVisible(false);
          setNewDirName('');
        }}
        okText="åˆ›å»º"
        cancelText="å–æ¶ˆ"
      >
        <Input
          placeholder="è¯·è¾“å…¥ç›®å½•åç§°"
          value={newDirName}
          onChange={(e) => setNewDirName(e.target.value)}
          onPressEnter={handleCreateDir}
          autoFocus
        />
      </Modal>

      {/* é‡å‘½åå¯¹è¯æ¡† */}
      <Modal
        title="é‡å‘½å"
        open={!!renamingItem}
        onOk={handleRename}
        onCancel={() => {
          setRenamingItem(null);
          setNewName('');
        }}
        okText="ç¡®å®š"
        cancelText="å–æ¶ˆ"
      >
        <Space direction="vertical" style={{ width: '100%' }}>
          <Text type="secondary">åŸåç§°: {renamingItem?.name}</Text>
          <Input
            placeholder="è¯·è¾“å…¥æ–°åç§°"
            value={newName}
            onChange={(e) => setNewName(e.target.value)}
            onPressEnter={handleRename}
            autoFocus
          />
        </Space>
      </Modal>

      {/* æ–‡ä»¶ç¼–è¾‘å™¨ */}
      <Modal
        title={
          <Space>
            <EditOutlined />
            <span>{editingFile ? `ç¼–è¾‘: ${editingFile.name}` : 'æ–°å»ºæ–‡ä»¶'}</span>
            {editingFile && (
              <Text type="secondary" style={{ fontSize: 12 }}>
                ({editingFile.name.split('.').pop()?.toUpperCase()} æ–‡ä»¶)
              </Text>
            )}
          </Space>
        }
        open={editModalVisible}
        onCancel={() => {
          setEditModalVisible(false);
          setEditingFile(null);
        }}
        width="80%"
        style={{ top: 20 }}
        footer={
          editingFile?.name.toLowerCase().endsWith('.csv') ? [
            <Button key="close" onClick={() => {
              setEditModalVisible(false);
              setEditingFile(null);
            }}>
              å…³é—­
            </Button>
          ] : [
            <Button key="cancel" onClick={() => {
              setEditModalVisible(false);
              setEditingFile(null);
            }}>
              å–æ¶ˆ
            </Button>,
            <Button key="save" type="primary" loading={saving} onClick={handleSaveFile}>
              ä¿å­˜
            </Button>
          ]
        }
      >
        <div style={{ marginBottom: 12 }}>
          <Space direction="vertical" style={{ width: '100%' }}>
            <Text type="secondary">
              æ–‡ä»¶è·¯å¾„: {editingFile?.path || ''}
            </Text>
            {!editingFile?.name.toLowerCase().endsWith('.csv') && (
              <Text type="secondary" style={{ fontSize: 12 }}>
                ğŸ’¡ æç¤º: æ”¯æŒè¯­æ³•é«˜äº®ã€ä»£ç è¡¥å…¨ã€Ctrl+Sä¿å­˜ã€Ctrl+FæŸ¥æ‰¾
              </Text>
            )}
          </Space>
        </div>
        <div style={{ border: '1px solid #d9d9d9', borderRadius: 4, overflow: 'hidden' }}>
          {editingFile?.name.toLowerCase().endsWith('.csv') ? (
            <CsvViewer content={fileContent} />
          ) : (
            <CodeEditor
              value={fileContent}
              onChange={setFileContent}
              fileName={editingFile?.name}
              height="500px"
            />
          )}
        </div>
      </Modal>

      {/* äº¤äº’å¼ç»ˆç«¯å¼¹çª— */}
      {terminalVisible && terminalScript && (
        <TerminalModal
          visible={terminalVisible}
          scriptPath={terminalScript.path}
          scriptName={terminalScript.name}
          onClose={() => {
            setTerminalVisible(false);
            setTerminalScript(null);
            addConsoleLog('='.repeat(60), 'info');
            addConsoleLog('äº¤äº’å¼ç»ˆç«¯å·²å…³é—­', 'info');
            addConsoleLog('='.repeat(60), 'info');
            loadFiles();
          }}
          onLog={(msg) => {
            // å°†ç»ˆç«¯è¾“å‡ºè®°å½•åˆ°æ§åˆ¶å°æ—¥å¿—
            const lines = msg.split('\n');
            lines.forEach(line => {
              if (line.trim()) {
                addConsoleLog(line, 'info');
              }
            });
          }}
        />
      )}
    </div>
  );
};

export default Workspace;
